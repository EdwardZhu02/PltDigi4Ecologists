<!DOCTYPE html>
{% extends 'master.html' %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <!-- Top Row: Controls -->
        <div class="col-12 mb-3">
            <div class="btn-group mb-2">
                <button onclick="startCalibration()" class="btn btn-primary"><span class="badge text-bg-secondary">1</span> Add Calibration</button>
                <button onclick="startAddingDataPoints()" class="btn btn-primary"><span class="badge text-bg-secondary">2</span> Add Data Points</button>
                <a class="btn btn-info" data-bs-toggle="collapse" href="#collapseInstructions" role="button" aria-expanded="false" aria-controls="collapseExample">
                    <span class="badge text-bg-light">?</span> Instructions
                </a>
            </div>
            <div class="collapse" id="collapseInstructions">
                <div class="card card-body">
                    <div class="instructions">
                        <p><strong>Instructions:</strong></p>
                        <ul>
                            <li><strong>Step1 (Add Calibration):</strong> Click on the image to calibrate axes (2 points for Y).</li>
                            <li><strong>Step2 (Add Data Points):</strong> After calibration, click on data points to extract their values.</li>
                            <li>Use Ctrl + Left Click to pan the image.</li>
                            <li>Use mouse wheel while holding Ctrl to zoom in/out.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <!-- Left Column: Image -->
        <div class="col-md-9">
            <div class="card">
                <h5 class="card-header">Interactive View (Mode: bar plot)</h5>
                <div class="card-body">
                    <div class="btn-group mb-2">
                        <button onclick="zoomIn()" class="btn btn-light btn-sm">Zoom In</button>
                        <button onclick="zoomOut()" class="btn btn-light btn-sm">Zoom Out</button>
                        <button onclick="resetZoom()" class="btn btn-light btn-sm">Reset View</button>
                        <span>Zoom: <span id="zoom-display">100%</span></span>
                    </div>
                    <div id="image-container" class="border rounded overflow-auto" style="height: 70vh;">
                        <div id="zoom-scene">
                            <img id="plot-image" src="/uploaded_images/{{ uploaded_image.image }}" alt="Uploaded Image" onclick="handleImageClick(event)" class="img-fluid">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Right Column: Extracted Data -->
        <div class="col-md-3">
            <div class="card">
                <h5 class="card-header">Extracted Data</h5>
                <div class="card-body">
                    <table class="table table-striped table-bordered table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Y</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="data-table-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <!-- Row: Controls -->
        <div class="col-12 mb-3">
            <div class="btn-group">
                <button onclick="resetCalibration()" class="btn btn-outline-danger">Reset Calibration</button>
                <button onclick="clearDataPoints()" class="btn btn-outline-danger">Clear Points</button>
                <button onclick="saveResults()" class="btn btn-primary">Save Results</button>
                <button onclick="exportToCSV()" class="btn btn-primary">Export to CSV</button>
            </div>
            <br><br>
            <div class="info-block">
                <span><strong>Calibration Details:</strong></span>
                <span>Y1: <span id="calibration-y1">N/A</span></span>
                <span>Y2: <span id="calibration-y2">N/A</span></span>
            </div>
        </div>
    </div>
</div>

<script>
    const existingAnalysis = {{ existing_analysis|default:'{}'|safe }};
    let calibration = { y: [] };
    let calibratedValue = null;
    let isCalibrating = false;
    let isAddingData = false;
    let extractedData = [];
    // Zoom & pan variables
    let zoomLevel = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    function handleImageClick(event) {
        if (isDragging) return;
        if (!isCalibrating && !isAddingData) return;
        const imageElement = document.querySelector("#plot-image");
        const imageRect = imageElement.getBoundingClientRect();
        // Calculate relative and original positions for X and Y
        const relativeX = (event.clientX - imageRect.left) / imageRect.width;
        const relativeY = (event.clientY - imageRect.top) / imageRect.height;
        const originalX = relativeX * imageElement.naturalWidth;
        const originalY = relativeY * imageElement.naturalHeight;
        if (isCalibrating) {
            if (calibration.y.length < 2) {
                calibration.y.push({ y: originalY, relativeX, relativeY });
                renderGreenDot(relativeX, relativeY, 'Y' + calibration.y.length);
                const value = prompt("Enter the value for this Y-axis point:");
                if (value !== null) calibration.y[calibration.y.length - 1].value = parseFloat(value);
            }
            if (calibration.y.length === 2) {
                isCalibrating = false;
                alert('Calibration complete!');
                calculateCalibration();
                updateCalibrationInfo();
            }
        } else if (isAddingData) {
            const realY = calculateRealY(originalY);
            const dotEl = renderRedDot(relativeX, relativeY);
            extractedData.push({ y: realY, relativeX, relativeY, dotEl });
            updateDataTable();
            sendExtractedData({ y: realY });
        }
    }

    function calculateCalibration() {
        calibratedValue = (calibration.y[1].value - calibration.y[0].value) / (calibration.y[1].y - calibration.y[0].y);
    }
    function calculateRealY(y) {
        return calibration.y[0].value + (y - calibration.y[0].y) * calibratedValue;
    }
    function renderRedDot(relativeX, relativeY) {
        const container = document.querySelector("#zoom-scene");
        const dot = document.createElement("div");
        dot.className = "data-dot red-dot";
        dot.style.left = `${relativeX * 100}%`;
        dot.style.top = `${relativeY * 100}%`;
        container.appendChild(dot);
        return dot;
    }
    function renderGreenDot(relativeX, relativeY, label) {
        const container = document.querySelector('#zoom-scene');
        const dot = document.createElement('div');
        dot.className = 'data-dot green-dot';
        dot.style.left = `${relativeX * 100}%`;
        dot.style.top = `${relativeY * 100}%`;
        if (label) {
            const lb = document.createElement('span');
            lb.className = 'dot-label';
            lb.textContent = label;
            dot.appendChild(lb);
        }
        container.appendChild(dot);
    }
    function exportToCSV() {
        const csvContent = ["Index,Y Value"];
        extractedData.forEach((data, index) => {
            csvContent.push(`${index + 1},${data.y.toFixed(2)}`);
        });
        const blob = new Blob([csvContent.join("\n")], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "barplot_data.csv";
        a.click();
        URL.revokeObjectURL(url);
    }
    function deleteDataPoint(index) {
        if (extractedData[index].dotElement) {
            extractedData[index].dotElement.remove();
        }
        extractedData.splice(index, 1);
        updateDataTable();
    }
    function highlightPoint(index) {
        const container = document.querySelector("#zoom-scene");
        const highlight = document.createElement("div");
        const dataPoint = extractedData[index];
        highlight.className = "data-dot highlight-dot";
        highlight.style.left = `${dataPoint.relativeX * 100}%`;
        highlight.style.top = `${dataPoint.relativeY * 100}%`;
        container.appendChild(highlight);
        setTimeout(() => highlight.remove(), 1000);
    }
    function updateDataTable() {
        const tableBody = document.getElementById("data-table-body");
        tableBody.innerHTML = "";
        extractedData.forEach((data, index) => {
            const row = document.createElement("tr");
            row.innerHTML = `<td>${index + 1}</td><td>${data.y.toFixed(2)}</td><td><a href="#" onclick="deleteDataPoint(${index})">Delete</a></td>`;
            row.addEventListener("click", () => highlightPoint(index));
            tableBody.appendChild(row);
        });
    }
    // Zoom & pan functions
    function zoomIn() {
        zoomLevel = Math.min(zoomLevel * 1.5, 5);
        updateImageTransform();
    }
    function zoomOut() {
        zoomLevel = Math.max(zoomLevel / 1.5, 0.5);
        updateImageTransform();
    }
    function resetZoom() {
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateImageTransform();
    }
    function updateImageTransform() {
        const scene = document.querySelector("#zoom-scene");
        scene.style.transform = `scale(${zoomLevel}) translate(${panX}px, ${panY}px)`;
        document.getElementById('zoom-display').textContent = Math.round(zoomLevel * 100) + '%';
    }
    function handleMouseDown(event) {
        if (event.button === 0 && event.ctrlKey) {
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            event.preventDefault();
        }
    }
    function handleMouseMove(event) {
        if (isDragging) {
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;
            panX += deltaX / zoomLevel;
            panY += deltaY / zoomLevel;
            updateImageTransform();
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
    }
    function handleMouseUp(event) {
        isDragging = false;
    }
    function handleWheel(event) {
        if (event.ctrlKey) {
            event.preventDefault();
            if (event.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        }
    }
    document.addEventListener('DOMContentLoaded', function() {
        const imageContainer = document.querySelector("#image-container");
        imageContainer.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        imageContainer.addEventListener('wheel', handleWheel);
        if (existingAnalysis.calibration) {
            existingAnalysis.calibration.y.forEach(pt => {
                calibration.y.push(pt);
                renderGreenDot(pt.relativeX, pt.relativeY, 'Y' + calibration.y.length);
            });
            if (calibration.y.length === 2) {
                calculateCalibration(); isCalibrating = false;
            }
            updateCalibrationInfo();
        }
        if (existingAnalysis.extractedData) {
            existingAnalysis.extractedData.forEach(pt => {
                const dot = renderRedDot(pt.relativeX, pt.relativeY);
                const dataPoint = { ...pt, dotElement: dot };
                extractedData.push(dataPoint);
            });
            updateDataTable();
        }
    });

    function sendCalibrationData() {
        fetch("", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}"
            },
            body: JSON.stringify({ calibration })
        })
        .then(response => response.json())
        .then(data => console.log("Calibration data sent successfully:", data))
        .catch(error => console.error("Error sending calibration data:", error));
    }

    function sendExtractedData(data) {
        fetch("", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}"
            },
            body: JSON.stringify({ extractedData: data })
        })
        .then(response => response.json())
        .then(data => console.log("Extracted data sent successfully:", data))
        .catch(error => console.error("Error sending extracted data:", error));
    }

    function resetCalibration() {
        calibration = { y: [] };
        calibratedValue = null;
        isCalibrating = false;
        // remove all green dots
        document.querySelectorAll('.green-dot').forEach(dot => dot.remove());
        // Clear all data points and red dots
        extractedData.forEach(dp => { if (dp.dotElement) dp.dotElement.remove(); });
        extractedData = [];
        updateDataTable();
        updateCalibrationInfo();
        alert('Calibration has been reset. Please re-calibrate axes and add data points.');
    }

    function clearDataPoints() {
        extractedData.forEach(dp => { if (dp.dotElement) dp.dotElement.remove(); });
        extractedData = [];
        updateDataTable();
    }

    function saveResults() {
        fetch('', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' },
            body: JSON.stringify({ saveResults: true, calibration, extractedData })
        })
        .then(res => res.json())
        .then(data => alert(data.message || 'Results saved'));
    }

    function startCalibration() {
        isCalibrating = true;
        isAddingData = false;
        calibration = { y: [] };
        document.querySelectorAll('.green-dot').forEach(dot => dot.remove());
        updateCalibrationInfo();
        alert('Click two points on Y axis to calibrate.');
    }

    function startAddingDataPoints() {
        if (calibration.y.length < 2) {
            alert('Please complete calibration first.'); return;
        }
        isAddingData = true;
        isCalibrating = false;
        alert('Click on bars to extract data points.');
    }

    function updateCalibrationInfo() {
        document.getElementById('calibration-y1').textContent = calibration.y[0]?.value || 'N/A';
        document.getElementById('calibration-y2').textContent = calibration.y[1]?.value || 'N/A';
    }

</script>
<style>
    #image-container { position: relative; display: inline-block; overflow: auto; border: 2px solid #ddd; max-width: 100%; max-height: 70vh; cursor: crosshair; }
    #zoom-scene { position: relative; transform-origin: top left; transition: transform 0.1s ease-out; width: fit-content; height: fit-content; }
    #plot-image { display: block; max-width: none; max-height: none; transform-origin: top left; transition: transform 0.1s ease-out; }
    .data-dot { position: absolute; border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%); z-index: 10; }
    .red-dot { width: 8px; height: 8px; background-color: #B02226; border: 1px solid whitesmoke; }
    .green-dot { width: 10px; height: 10px; background-color: #38C1F3; border: 1px solid whitesmoke; }
    .highlight-dot { width: 15px; height: 15px; background-color: #F0A12C; border: 2px solid whitesmoke; animation: pulse 0.5s ease-in-out; }
    @keyframes pulse { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.5); } 100% { transform: translate(-50%, -50%) scale(1); } }
    .zoom-controls { margin: 10px 0; }
    .zoom-controls button { margin-right: 10px; }
    .instructions { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-top: 20px; }
    .table {
        display: block;
        max-height: 60vh;
        overflow-y: auto;
    }
    .dot-label { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); background: white; padding: 2px 4px; border: 1px solid #ccc; border-radius:3px; font-size:12px; }
</style>
{% endblock %}
