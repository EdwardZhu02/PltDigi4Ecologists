<!DOCTYPE html>
{% extends 'master.html' %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <!-- Top Row: Controls -->
        <div class="col-12 mb-3">
            <div class="btn-group mb-2">
                <button onclick="zoomIn()" class="btn btn-secondary">Zoom In</button>
                <button onclick="zoomOut()" class="btn btn-secondary">Zoom Out</button>
                <button onclick="resetZoom()" class="btn btn-secondary">Reset View</button>
            </div>
            <p>Zoom: <span id="zoom-display">100%</span></p>
        </div>
    </div>

    <div class="row">
        <!-- Left Column: Image -->
        <div class="col-md-9">
            <h4>Interactive View</h4>
            <div id="image-container" class="border rounded overflow-auto" style="height: 70vh;">
                <div id="zoom-scene">
                    <img id="plot-image" src="/uploaded_images/{{ uploaded_image.image }}" alt="Uploaded Image" onclick="handleImageClick(event)" class="img-fluid">
                </div>
            </div>
        </div>
        <!-- Right Column: Extracted Data -->
        <div class="col-md-3">
            <h4>Extracted Data</h4>
            <table class="table table-striped table-bordered table-hover">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>X Value</th>
                        <th>Y Value</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="data-table-body">
                </tbody>
            </table>
        </div>
    </div>

    <div class="row">
        <!-- Row: Controls -->
        <div class="col-12 mb-3">
            <div class="btn-group">
                <button onclick="resetCalibration()" class="btn btn-warning">Reset Calibration</button>
                <button onclick="clearDataPoints()" class="btn btn-warning">Clear Points</button>
                <button onclick="saveResults()" class="btn btn-success">Save Results</button>
                <button onclick="exportToCSV()" class="btn btn-primary">Export to CSV</button>
            </div>
        </div>
    </div>

    <div class="row mt-4">
        <!-- Row: Instructions -->
        <div class="col-12">
            <div class="instructions">
                <p><strong>Instructions:</strong></p>
                <ul>
                    <li>Click on the image to calibrate axes (2 points for X, 2 points for Y).</li>
                    <li>After calibration, click on data points to extract their values.</li>
                    <li>Use Ctrl + Left Click to pan the image.</li>
                    <li>Use mouse wheel while holding Ctrl to zoom in/out.</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<script>
    const existingAnalysis = {{ existing_analysis|default:'{}'|safe }};
    let calibration = {
        x: [],
        y: []
    };
    let calibratedValues = {
        x: null,
        y: null
    };
    let isCalibrating = true;
    let extractedData = [];

    // Zoom and pan variables
    let zoomLevel = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    function handleImageClick(event) {
        if (isDragging) return; // Don't process clicks during drag

        const rect = event.target.getBoundingClientRect();
        const imageElement = document.querySelector("#plot-image");
        const imageRect = imageElement.getBoundingClientRect();

        // Calculate relative position within the image (0 to 1)
        const relativeX = (event.clientX - imageRect.left) / imageRect.width;
        const relativeY = (event.clientY - imageRect.top) / imageRect.height;

        // Convert to original image coordinates
        const originalX = relativeX * imageElement.naturalWidth;
        const originalY = relativeY * imageElement.naturalHeight;

        if (isCalibrating) {
            if (calibration.x.length < 2) {
                calibration.x.push({ x: originalX, y: originalY, relativeX, relativeY });
                renderGreenDot(relativeX, relativeY);
                alert(`X-axis calibration point ${calibration.x.length} recorded. Please input the value.`);
                const value = prompt("Enter the value for this X-axis point:");
                if (value !== null) {
                    calibration.x[calibration.x.length - 1].value = parseFloat(value);
                }
            } else if (calibration.y.length < 2) {
                calibration.y.push({ x: originalX, y: originalY, relativeX, relativeY });
                renderGreenDot(relativeX, relativeY);
                alert(`Y-axis calibration point ${calibration.y.length} recorded. Please input the value.`);
                const value = prompt("Enter the value for this Y-axis point:");
                if (value !== null) {
                    calibration.y[calibration.y.length - 1].value = parseFloat(value);
                }
            }

            if (calibration.x.length === 2 && calibration.y.length === 2) {
                isCalibrating = false;
                alert("Calibration complete! You can now click on data points.");
                calculateCalibration();
                sendCalibrationData();
            }
        } else {
            const realValues = calculateRealValues(originalX, originalY);
            const dotElement = renderRedDot(relativeX, relativeY);
            const dataPoint = {
                ...realValues,
                originalX,
                originalY,
                relativeX,
                relativeY,
                dotElement: dotElement
            };
            extractedData.push(dataPoint);
            updateDataTable();
            sendExtractedData(realValues);
        }
    }

    function calculateCalibration() {
        calibratedValues.x = (calibration.x[1].value - calibration.x[0].value) / (calibration.x[1].x - calibration.x[0].x);
        calibratedValues.y = (calibration.y[1].value - calibration.y[0].value) / (calibration.y[1].y - calibration.y[0].y);
    }

    function calculateRealValues(x, y) {
        const realX = calibration.x[0].value + (x - calibration.x[0].x) * calibratedValues.x;
        const realY = calibration.y[0].value + (y - calibration.y[0].y) * calibratedValues.y;
        return { x: realX, y: realY };
    }

    function renderRedDot(relativeX, relativeY) {
        const container = document.querySelector("#zoom-scene");
        const dot = document.createElement("div");
        dot.className = "data-dot red-dot";
        dot.style.left = `${relativeX * 100}%`;
        dot.style.top = `${relativeY * 100}%`;
        container.appendChild(dot);
        return dot;
    }

    function renderGreenDot(relativeX, relativeY) {
        const container = document.querySelector("#zoom-scene");
        const dot = document.createElement("div");
        dot.className = "data-dot green-dot";
        dot.style.left = `${relativeX * 100}%`;
        dot.style.top = `${relativeY * 100}%`;
        container.appendChild(dot);
    }

    function exportToCSV() {
        const csvContent = ["Index,X Value,Y Value"];
        extractedData.forEach((data, index) => {
            csvContent.push(`${index + 1},${data.x.toFixed(2)},${data.y.toFixed(2)}`);
        });
        const blob = new Blob([csvContent.join("\n")], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "extracted_data.csv";
        a.click();
        URL.revokeObjectURL(url);
    }

    function deleteDataPoint(index) {
        if (extractedData[index].dotElement) {
            extractedData[index].dotElement.remove();
        }
        extractedData.splice(index, 1);
        updateDataTable();
    }

    function highlightPoint(index) {
        const container = document.querySelector("#zoom-scene");
        const highlight = document.createElement("div");
        const dataPoint = extractedData[index];
        highlight.className = "data-dot highlight-dot";
        highlight.style.left = `${dataPoint.relativeX * 100}%`;
        highlight.style.top = `${dataPoint.relativeY * 100}%`;
        container.appendChild(highlight);
        setTimeout(() => highlight.remove(), 1000);
    }

    function updateDataTable() {
        const tableBody = document.getElementById("data-table-body");
        tableBody.innerHTML = "";
        extractedData.forEach((data, index) => {
            const row = document.createElement("tr");
            row.innerHTML = `<td>${index + 1}</td><td>${data.x.toFixed(2)}</td><td>${data.y.toFixed(2)}</td><td><a href="#" onclick="deleteDataPoint(${index})">Delete</a></td>`;
            row.addEventListener("click", () => highlightPoint(index));
            tableBody.appendChild(row);
        });
    }

    // Zoom and pan functions
    function zoomIn() {
        zoomLevel = Math.min(zoomLevel * 1.5, 5);
        updateImageTransform();
    }

    function zoomOut() {
        zoomLevel = Math.max(zoomLevel / 1.5, 0.5);
        updateImageTransform();
    }

    function resetZoom() {
        zoomLevel = 1;
        panX = 0;
        panY = 0;
        updateImageTransform();
    }

    function updateImageTransform() {
        const scene = document.querySelector("#zoom-scene");
        scene.style.transform = `scale(${zoomLevel}) translate(${panX}px, ${panY}px)`;
        document.getElementById('zoom-display').textContent = Math.round(zoomLevel * 100) + '%';
    }

    // Mouse event handlers for panning
    function handleMouseDown(event) {
        if (event.button === 0 && event.ctrlKey) { // Left click + Ctrl for panning
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            event.preventDefault();
        }
    }

    function handleMouseMove(event) {
        if (isDragging) {
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;
            panX += deltaX / zoomLevel;
            panY += deltaY / zoomLevel;
            updateImageTransform();
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
    }

    function handleMouseUp(event) {
        isDragging = false;
    }

    // Wheel event for zooming
    function handleWheel(event) {
        if (event.ctrlKey) {
            event.preventDefault();
            if (event.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        }
    }

    // Initialize event listeners
    document.addEventListener('DOMContentLoaded', function() {
        const imageContainer = document.querySelector("#image-container");
        imageContainer.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        imageContainer.addEventListener('wheel', handleWheel);

        if (existingAnalysis.calibration) {
            // load calibration
            existingAnalysis.calibration.x.forEach(pt => { calibration.x.push(pt); renderGreenDot(pt.relativeX, pt.relativeY); });
            existingAnalysis.calibration.y.forEach(pt => { calibration.y.push(pt); renderGreenDot(pt.relativeX, pt.relativeY); });
            if (calibration.x.length === 2 && calibration.y.length === 2) {
                calculateCalibration(); isCalibrating = false;
            }
        }
        if (existingAnalysis.extractedData) {
            existingAnalysis.extractedData.forEach(pt => {
                const dot = renderRedDot(pt.relativeX, pt.relativeY);
                const dataPoint = { ...pt, dotElement: dot };
                extractedData.push(dataPoint);
            });
            updateDataTable();
        }
    });

    function sendCalibrationData() {
        fetch("", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}"
            },
            body: JSON.stringify({ calibration })
        })
        .then(response => response.json())
        .then(data => console.log("Calibration data sent successfully:", data))
        .catch(error => console.error("Error sending calibration data:", error));
    }

    function sendExtractedData(data) {
        fetch("", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}"
            },
            body: JSON.stringify({ extractedData: data })
        })
        .then(response => response.json())
        .then(data => console.log("Extracted data sent successfully:", data))
        .catch(error => console.error("Error sending extracted data:", error));
    }

    // Reset calibration and green dots
    function resetCalibration() {
        calibration = { x: [], y: [] };
        calibratedValues = { x: null, y: null };
        isCalibrating = true;
        // remove all green dots
        document.querySelectorAll('.green-dot').forEach(dot => dot.remove());
        alert('Calibration has been reset. Please re-calibrate axes.');
    }

    // Clear all data points and red dots
    function clearDataPoints() {
        extractedData.forEach(dp => { if (dp.dotElement) dp.dotElement.remove(); });
        extractedData = [];
        updateDataTable();
    }

    // Save analysis JSON
    function saveResults() {
        fetch('', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' },
            body: JSON.stringify({ saveResults: true, calibration, extractedData })
        })
        .then(res => res.json())
        .then(data => alert(data.message || 'Results saved'));
    }
</script>

<style>
    #image-container {
        position: relative;
        display: inline-block;
        overflow: auto; /* Enable scroll bars */
        border: 2px solid #ddd;
        max-width: 100%;
        max-height: 70vh;
        cursor: crosshair;
    }

    #zoom-scene {
        position: relative;
        transform-origin: top left;
        transition: transform 0.1s ease-out;
        width: fit-content; /* Ensure the scene scales properly */
        height: fit-content;
    }

    #plot-image {
        display: block;
        max-width: none;
        max-height: none;
        transform-origin: top left;
        transition: transform 0.1s ease-out;
    }

    .data-dot {
        position: absolute;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 10;
    }

    .red-dot {
        width: 8px;
        height: 8px;
        background-color: #B02226;
        border: 1px solid whitesmoke;
    }

    .green-dot {
        width: 10px;
        height: 10px;
        background-color: #38C1F3;
        border: 1px solid whitesmoke;
    }

    .highlight-dot {
        width: 15px;
        height: 15px;
        background-color: #F0A12C;
        border: 2px solid whitesmoke;
        animation: pulse 0.5s ease-in-out;
    }

    @keyframes pulse {
        0% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.5); }
        100% { transform: translate(-50%, -50%) scale(1); }
    }

    .zoom-controls {
        margin: 10px 0;
    }

    .zoom-controls button {
        margin-right: 10px;
    }

    .instructions {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
    }

    .table {
        display: block;
        max-height: 60vh;
        overflow-y: auto;
    }
</style>


{% endblock %}
