<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Mainapp/templates/interactive_biplot.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Mainapp/templates/interactive_biplot.html" />
              <option name="originalContent" value="&lt;!DOCTYPE html&gt;&#10;{% extends 'master.html' %}&#10;&#10;{% block content %}&#10;&lt;div class=&quot;container mt-4&quot;&gt;&#10;    &lt;div class=&quot;row&quot;&gt;&#10;        &lt;div class=&quot;col-12 mb-3&quot;&gt;&#10;            &lt;div class=&quot;btn-group mb-2&quot;&gt;&#10;                &lt;button onclick=&quot;startAxesCalibration()&quot; class=&quot;btn btn-primary&quot;&gt;&lt;span class=&quot;badge text-bg-secondary&quot;&gt;1&lt;/span&gt; Calibrate Axes&lt;/button&gt;&#10;                &lt;button onclick=&quot;startCenterCalibration()&quot; class=&quot;btn btn-primary&quot;&gt;&lt;span class=&quot;badge text-bg-secondary&quot;&gt;2&lt;/span&gt; Mark Center&lt;/button&gt;&#10;                &lt;button onclick=&quot;startAddingArrows()&quot; class=&quot;btn btn-primary&quot;&gt;&lt;span class=&quot;badge text-bg-secondary&quot;&gt;3&lt;/span&gt; Add Variable Arrows&lt;/button&gt;&#10;                &lt;a class=&quot;btn btn-info&quot; data-bs-toggle=&quot;collapse&quot; href=&quot;#collapseInstructions&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot;&gt;&#10;                    &lt;span class=&quot;badge text-bg-light&quot;&gt;?&lt;/span&gt; Instructions&#10;                &lt;/a&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;collapse&quot; id=&quot;collapseInstructions&quot;&gt;&#10;                &lt;div class=&quot;card card-body&quot;&gt;&#10;                    &lt;div class=&quot;instructions&quot;&gt;&#10;                        &lt;p&gt;&lt;strong&gt;Instructions:&lt;/strong&gt;&lt;/p&gt;&#10;                        &lt;ul&gt;&#10;                            &lt;li&gt;&lt;strong&gt;Step1 (Calibrate Axes):&lt;/strong&gt; Click two points on X axis then two on Y axis.&lt;/li&gt;&#10;                            &lt;li&gt;&lt;strong&gt;Step2 (Mark Center):&lt;/strong&gt; Click on the biplot origin where arrows start.&lt;/li&gt;&#10;                            &lt;li&gt;&lt;strong&gt;Step3 (Add Variable Arrows):&lt;/strong&gt; Click on arrow tips, then enter variable name.&lt;/li&gt;&#10;                            &lt;li&gt;Use Ctrl + Left Click to pan the image and Ctrl + Mouse Wheel to zoom.&lt;/li&gt;&#10;                        &lt;/ul&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;row&quot;&gt;&#10;        &lt;div class=&quot;col-md-9&quot;&gt;&#10;            &lt;div class=&quot;card&quot;&gt;&#10;                &lt;h5 class=&quot;card-header&quot;&gt;Interactive View (Mode: biplot)&lt;/h5&gt;&#10;                &lt;div class=&quot;card-body&quot;&gt;&#10;                    &lt;div class=&quot;btn-group mb-2&quot;&gt;&#10;                        &lt;button onclick=&quot;zoomIn()&quot; class=&quot;btn btn-light btn-sm&quot;&gt;Zoom In&lt;/button&gt;&#10;                        &lt;button onclick=&quot;zoomOut()&quot; class=&quot;btn btn-light btn-sm&quot;&gt;Zoom Out&lt;/button&gt;&#10;                        &lt;button onclick=&quot;resetZoom()&quot; class=&quot;btn btn-light btn-sm&quot;&gt;Reset View&lt;/button&gt;&#10;                        &lt;span&gt;Zoom: &lt;span id=&quot;zoom-display&quot;&gt;100%&lt;/span&gt;&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;div id=&quot;image-container&quot; class=&quot;border rounded overflow-auto&quot; style=&quot;height: 70vh;&quot;&gt;&#10;                        &lt;div id=&quot;zoom-scene&quot;&gt;&#10;                            &lt;img id=&quot;plot-image&quot; src=&quot;/uploaded_images/{{ uploaded_image.image }}&quot; alt=&quot;Uploaded Image&quot; onclick=&quot;handleImageClick(event)&quot; class=&quot;img-fluid&quot;&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;col-md-3&quot;&gt;&#10;            &lt;div class=&quot;card&quot;&gt;&#10;                &lt;h5 class=&quot;card-header&quot;&gt;Extracted Data&lt;/h5&gt;&#10;                &lt;div class=&quot;card-body&quot;&gt;&#10;                    &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt;&#10;                        &lt;thead&gt;&#10;                            &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Variable&lt;/th&gt;&lt;th&gt;PC1&lt;/th&gt;&lt;th&gt;PC2&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;/tr&gt;&#10;                        &lt;/thead&gt;&#10;                        &lt;tbody id=&quot;data-table-body&quot;&gt;&lt;/tbody&gt;&#10;                    &lt;/table&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;row&quot;&gt;&#10;        &lt;div class=&quot;col-12 mb-3&quot;&gt;&#10;            &lt;div class=&quot;btn-group&quot;&gt;&#10;                &lt;button onclick=&quot;resetCalibration()&quot; class=&quot;btn btn-outline-danger&quot;&gt;Reset All&lt;/button&gt;&#10;                &lt;button onclick=&quot;clearArrows()&quot; class=&quot;btn btn-outline-danger&quot;&gt;Clear Arrows&lt;/button&gt;&#10;                &lt;button onclick=&quot;saveResults()&quot; class=&quot;btn btn-primary&quot;&gt;Save Results&lt;/button&gt;&#10;                &lt;button onclick=&quot;exportToCSV()&quot; class=&quot;btn btn-primary&quot;&gt;Export to CSV&lt;/button&gt;&#10;            &lt;/div&gt;&#10;            &lt;br&gt;&lt;br&gt;&#10;            &lt;div class=&quot;info-block&quot;&gt;&#10;                &lt;span&gt;&lt;strong&gt;Calibration Details:&lt;/strong&gt;&lt;/span&gt;&#10;                &lt;span&gt;X1: &lt;span id=&quot;calibration-x1&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;X2: &lt;span id=&quot;calibration-x2&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;Y1: &lt;span id=&quot;calibration-y1&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;Y2: &lt;span id=&quot;calibration-y2&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;Center: &lt;span id=&quot;calibration-center&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;script&gt;&#10;    const existingAnalysis = {{ existing_analysis|default:'{}'|safe }};&#10;    let calibration = { x: [], y: [], center: null };&#10;    let calibratedValues = { x: null, y: null };&#10;    let centerReal = null;&#10;    let isCalibratingAxes = false;&#10;    let isCalibratingCenter = false;&#10;    let isAddingArrows = false;&#10;    let extractedArrows = [];&#10;    let zoomLevel = 1, panX = 0, panY = 0, isDragging = false, lastMouseX = 0, lastMouseY = 0;&#10;&#10;    function handleImageClick(event) {&#10;        if (isDragging) return;&#10;        if (isCalibratingAxes) {&#10;            const img = document.querySelector('#plot-image');&#10;            const rect = img.getBoundingClientRect();&#10;            const relativeX = (event.clientX - rect.left) / rect.width;&#10;            const relativeY = (event.clientY - rect.top) / rect.height;&#10;            const originalX = relativeX * img.naturalWidth;&#10;            const originalY = relativeY * img.naturalHeight;&#10;            if (calibration.x.length &lt; 2) {&#10;                calibration.x.push({ x: originalX, y: originalY, relativeX, relativeY });&#10;                renderGreenDot(relativeX, relativeY, 'X' + calibration.x.length);&#10;                const val = prompt('Enter PC1 value for this point:'); if (val!==null) calibration.x[calibration.x.length-1].value = parseFloat(val);&#10;            } else if (calibration.y.length &lt; 2) {&#10;                calibration.y.push({ x: originalX, y: originalY, relativeX, relativeY });&#10;                renderGreenDot(relativeX, relativeY, 'Y' + calibration.y.length);&#10;                const val = prompt('Enter PC2 value for this point:'); if (val!==null) calibration.y[calibration.y.length-1].value = parseFloat(val);&#10;            }&#10;            if (calibration.x.length===2 &amp;&amp; calibration.y.length===2) {&#10;                isCalibratingAxes = false;&#10;                calculateCalibration();&#10;                updateCalibrationInfo();&#10;                alert('Axes calibration complete');&#10;            }&#10;        } else if (isCalibratingCenter) {&#10;            const img = document.querySelector('#plot-image');&#10;            const rect = img.getBoundingClientRect();&#10;            const relativeX = (event.clientX - rect.left) / rect.width;&#10;            const relativeY = (event.clientY - rect.top) / rect.height;&#10;            const originalX = relativeX * img.naturalWidth;&#10;            const originalY = relativeY * img.naturalHeight;&#10;            calibration.center = { x: originalX, y: originalY, relativeX, relativeY };&#10;            renderGreenDot(relativeX, relativeY, 'Center');&#10;            centerReal = calculateRealValues(originalX, originalY);&#10;            isCalibratingCenter = false;&#10;            alert('Center marked');&#10;        } else if (isAddingArrows) {&#10;            if (!centerReal) { alert('Please calibrate axes and center first'); return; }&#10;            const img = document.querySelector('#plot-image');&#10;            const rect = img.getBoundingClientRect();&#10;            const relativeX = (event.clientX - rect.left) / rect.width;&#10;            const relativeY = (event.clientY - rect.top) / rect.height;&#10;            const originalX = relativeX * img.naturalWidth;&#10;            const originalY = relativeY * img.naturalHeight;&#10;            const real = calculateRealValues(originalX, originalY);&#10;            const loadingX = real.x - centerReal.x;&#10;            const loadingY = real.y - centerReal.y;&#10;            const name = prompt('Enter variable name:'); if (!name) return;&#10;            const dot = renderRedDot(relativeX, relativeY);&#10;            extractedArrows.push({ name, loadingX, loadingY, relativeX, relativeY, dotElement: dot });&#10;            updateDataTable();&#10;            if (extractedArrows.length&gt;1) {&#10;                const prev = extractedArrows[extractedArrows.length-2]; const curr = extractedArrows[extractedArrows.length-1];&#10;                const angle = calculateAngle({x:prev.loadingX,y:prev.loadingY},{x:curr.loadingX,y:curr.loadingY});&#10;                alert(`Angle between ${prev.name} and ${curr.name}: ${angle.toFixed(2)}°`);&#10;            }&#10;        }&#10;    }&#10;&#10;    function calculateCalibration() {&#10;        calibratedValues.x = (calibration.x[1].value - calibration.x[0].value) / (calibration.x[1].x - calibration.x[0].x);&#10;        calibratedValues.y = (calibration.y[1].value - calibration.y[0].value) / (calibration.y[1].y - calibration.y[0].y);&#10;    }&#10;    function calculateRealValues(origX, origY) {&#10;        const realX = calibration.x[0].value + (origX - calibration.x[0].x) * calibratedValues.x;&#10;        const realY = calibration.y[0].value + (origY - calibration.y[0].y) * calibratedValues.y;&#10;        return { x: realX, y: realY };&#10;    }&#10;    function calculateAngle(v1, v2) {&#10;        const dot = v1.x * v2.x + v1.y * v2.y;&#10;        const mag1 = Math.hypot(v1.x, v1.y);&#10;        const mag2 = Math.hypot(v2.x, v2.y);&#10;        return Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);&#10;    }&#10;    function renderGreenDot(relX, relY, label) {&#10;        const container = document.querySelector('#zoom-scene');&#10;        const dot = document.createElement('div'); dot.className = 'data-dot green-dot';&#10;        dot.style.left = `${relX * 100}%`; dot.style.top = `${relY * 100}%`;&#10;        if (label) { const lb = document.createElement('span'); lb.className = 'dot-label'; lb.textContent = label; dot.appendChild(lb); }&#10;        container.appendChild(dot);&#10;    }&#10;    function renderRedDot(relX, relY) {&#10;        const container = document.querySelector('#zoom-scene');&#10;        const dot = document.createElement('div'); dot.className = 'data-dot red-dot';&#10;        dot.style.left = `${relX * 100}%`; dot.style.top = `${relY * 100}%`;&#10;        container.appendChild(dot); return dot;&#10;    }&#10;    function updateDataTable() {&#10;        const tbody = document.getElementById('data-table-body'); tbody.innerHTML = '';&#10;        extractedArrows.forEach((d, i) =&gt; {&#10;            const tr = document.createElement('tr');&#10;            tr.innerHTML = `&lt;td&gt;${i+1}&lt;/td&gt;&lt;td&gt;${d.name}&lt;/td&gt;&lt;td&gt;${d.loadingX.toFixed(2)}&lt;/td&gt;&lt;td&gt;${d.loadingY.toFixed(2)}&lt;/td&gt;&lt;td&gt;&lt;a href='#' onclick=&quot;deleteArrow(${i})&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;`;&#10;            tr.addEventListener('click', () =&gt; highlightArrow(i));&#10;            tbody.appendChild(tr);&#10;        });&#10;    }&#10;    function deleteArrow(idx) {&#10;        if (extractedArrows[idx].dotElement) extractedArrows[idx].dotElement.remove();&#10;        extractedArrows.splice(idx,1); updateDataTable();&#10;    }&#10;    function highlightArrow(idx) {&#10;        const data = extractedArrows[idx];&#10;        const hl = document.createElement('div'); hl.className='data-dot highlight-dot';&#10;        hl.style.left=`${data.relativeX*100}%`; hl.style.top=`${data.relativeY*100}%`;&#10;        document.querySelector('#zoom-scene').appendChild(hl);&#10;        setTimeout(()=&gt;hl.remove(),1000);&#10;    }&#10;    function startAxesCalibration() { isCalibratingAxes=true; isCalibratingCenter=false; isAddingArrows=false; calibration={x:[],y:[],center:null}; existingAnalysis; document.querySelectorAll('.data-dot').forEach(el=&gt;el.remove()); updateCalibrationInfo(); alert('Select two X-axis points and two Y-axis points'); }&#10;    function startCenterCalibration() { if (!calibratedValues.x) { alert('Calibrate axes first'); return;} isCalibratingCenter=true; isCalibratingAxes=false; isAddingArrows=false; alert('Select center point'); }&#10;    function startAddingArrows() { if (!centerReal) { alert('Mark center first'); return;} isAddingArrows=true; isCalibratingAxes=false; isCalibratingCenter=false; alert('Click arrow tips to add variables'); }&#10;    function updateCalibrationInfo() {&#10;        document.getElementById('calibration-x1').textContent = calibration.x[0]?.value||'N/A';&#10;        document.getElementById('calibration-x2').textContent = calibration.x[1]?.value||'N/A';&#10;        document.getElementById('calibration-y1').textContent = calibration.y[0]?.value||'N/A';&#10;        document.getElementById('calibration-y2').textContent = calibration.y[1]?.value||'N/A';&#10;        document.getElementById('calibration-center').textContent = centerReal?`(${centerReal.x.toFixed(2)},${centerReal.y.toFixed(2)})`:'N/A';&#10;    }&#10;    function resetCalibration() { calibration={x:[],y:[],center:null}; calibratedValues={x:null,y:null}; centerReal=null; isCalibratingAxes=isCalibratingCenter=isAddingArrows=false; document.querySelectorAll('.data-dot').forEach(el=&gt;el.remove()); extractedArrows=[]; updateDataTable(); updateCalibrationInfo(); }&#10;    function clearArrows() { extractedArrows.forEach(d=&gt;d.dotElement.remove()); extractedArrows=[]; updateDataTable(); }&#10;    function exportToCSV() { const rows=['Variable,PC1,PC2']; extractedArrows.forEach((d,i)=&gt;rows.push(`${d.name},${d.loadingX.toFixed(2)},${d.loadingY.toFixed(2)}`)); const blob=new Blob([rows.join('\n')],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='biplot_data.csv'; a.click(); URL.revokeObjectURL(url); }&#10;    function saveResults() { fetch('',{method:'POST',headers:{'Content-Type':'application/json','X-CSRFToken':'{{ csrf_token }}'},body:JSON.stringify({saveResults:true,calibration,extractedData:extractedArrows})}).then(r=&gt;r.json()).then(d=&gt;alert(d.message||'Saved')); }&#10;    function zoomIn(){zoomLevel=Math.min(zoomLevel*1.5,5);updateImageTransform();}&#10;    function zoomOut(){zoomLevel=Math.max(zoomLevel/1.5,0.5);updateImageTransform();}&#10;    function resetZoom(){zoomLevel=1;panX=0;panY=0;updateImageTransform();}&#10;    function updateImageTransform(){const s=document.querySelector('#zoom-scene');s.style.transform=`scale(${zoomLevel}) translate(${panX}px,${panY}px)`;document.getElementById('zoom-display').textContent=Math.round(zoomLevel*100)+'%';}&#10;    function handleMouseDown(e){if(e.button===0&amp;&amp;e.ctrlKey){isDragging=true;lastMouseX=e.clientX;lastMouseY=e.clientY; e.preventDefault();}}&#10;    function handleMouseMove(e){if(isDragging){const dx=e.clientX-lastMouseX,dy=e.clientY-lastMouseY;panX+=dx/zoomLevel;panY+=dy/zoomLevel;updateImageTransform();lastMouseX=e.clientX;lastMouseY=e.clientY;}}&#10;    function handleMouseUp(){isDragging=false;}&#10;    function handleWheel(e){if(e.ctrlKey){e.preventDefault();e.deltaY&lt;0?zoomIn():zoomOut();}}&#10;    document.addEventListener('DOMContentLoaded',()=&gt;{&#10;        const ic=document.querySelector('#image-container');ic.addEventListener('mousedown',handleMouseDown);document.addEventListener('mousemove',handleMouseMove);document.addEventListener('mouseup',handleMouseUp);ic.addEventListener('wheel',handleWheel);&#10;        if(existingAnalysis.calibration){ calibration=existingAnalysis.calibration; calibration.center=existingAnalysis.calibration.center; calculateCalibration(); centerReal=calculateRealValues(calibration.center.x,calibration.center.y); calibration.x.forEach((pt,i)=&gt;renderGreenDot(pt.relativeX,pt.relativeY,'X'+(i+1))); calibration.y.forEach((pt,i)=&gt;renderGreenDot(pt.relativeX,pt.relativeY,'Y'+(i+1))); renderGreenDot(calibration.center.relativeX,calibration.center.relativeY,'Center'); updateCalibrationInfo(); }&#10;        if(existingAnalysis.extractedData){ existingAnalysis.extractedData.forEach(pt=&gt;{ const dot=renderRedDot(pt.relativeX,pt.relativeY); extractedArrows.push({...pt,dotElement:dot}); }); updateDataTable(); }&#10;    });&#10;&lt;/script&gt;&#10;&lt;style&gt;&#10;    #image-container{position:relative;overflow:auto;border:2px solid #ddd;max-width:100%;max-height:70vh;cursor:crosshair;}&#10;    #zoom-scene{position:relative;transform-origin:top left;transition:transform .1s ease-out;width:fit-content;height:fit-content;}&#10;    #plot-image{display:block;max-width:none;max-height:none;transform-origin:top left;transition:transform .1s ease-out;}&#10;    .data-dot{position:absolute;border-radius:50%;pointer-events:none;transform:translate(-50%,-50%);z-index:10;}&#10;    .red-dot{width:8px;height:8px;background-color:#B02226;border:1px solid whitesmoke;}&#10;    .green-dot{width:10px;height:10px;background-color:#38C1F3;border:1px solid whitesmoke;}&#10;    .highlight-dot{width:15px;height:15px;background-color:#F0A12C;border:2px solid whitesmoke;animation:pulse .5s ease-in-out;}&#10;    @keyframes pulse{0%{transform:translate(-50%,-50%) scale(1);}50%{transform:translate(-50%,-50%) scale(1.5);}100%{transform:translate(-50%,-50%) scale(1);} }&#10;    .dot-label{position:absolute;top:-20px;left:50%;transform:translateX(-50%);background:white;padding:2px 4px;border:1px solid #ccc;border-radius:3px;font-size:12px;}&#10;&lt;/style&gt;&#10;{% endblock %}&#10;" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;{% extends 'master.html' %}&#10;&#10;{% block content %}&#10;&lt;div class=&quot;container mt-4&quot;&gt;&#10;    &lt;div class=&quot;row&quot;&gt;&#10;        &lt;div class=&quot;col-12 mb-3&quot;&gt;&#10;            &lt;div class=&quot;btn-group mb-2&quot;&gt;&#10;                &lt;button onclick=&quot;startAxesCalibration()&quot; class=&quot;btn btn-primary&quot;&gt;&lt;span class=&quot;badge text-bg-secondary&quot;&gt;1&lt;/span&gt; Calibrate Axes&lt;/button&gt;&#10;                &lt;button onclick=&quot;startCenterCalibration()&quot; class=&quot;btn btn-primary&quot;&gt;&lt;span class=&quot;badge text-bg-secondary&quot;&gt;2&lt;/span&gt; Mark Center&lt;/button&gt;&#10;                &lt;button onclick=&quot;startAddingArrows()&quot; class=&quot;btn btn-primary&quot;&gt;&lt;span class=&quot;badge text-bg-secondary&quot;&gt;3&lt;/span&gt; Add Variable Arrows&lt;/button&gt;&#10;                &lt;a class=&quot;btn btn-info&quot; data-bs-toggle=&quot;collapse&quot; href=&quot;#collapseInstructions&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot;&gt;&#10;                    &lt;span class=&quot;badge text-bg-light&quot;&gt;?&lt;/span&gt; Instructions&#10;                &lt;/a&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;collapse&quot; id=&quot;collapseInstructions&quot;&gt;&#10;                &lt;div class=&quot;card card-body&quot;&gt;&#10;                    &lt;div class=&quot;instructions&quot;&gt;&#10;                        &lt;p&gt;&lt;strong&gt;Instructions:&lt;/strong&gt;&lt;/p&gt;&#10;                        &lt;ul&gt;&#10;                            &lt;li&gt;&lt;strong&gt;Step1 (Calibrate Axes):&lt;/strong&gt; Click two points on X axis then two on Y axis.&lt;/li&gt;&#10;                            &lt;li&gt;&lt;strong&gt;Step2 (Mark Center):&lt;/strong&gt; Click on the biplot origin where arrows start.&lt;/li&gt;&#10;                            &lt;li&gt;&lt;strong&gt;Step3 (Add Variable Arrows):&lt;/strong&gt; Click on arrow tips, then enter variable name.&lt;/li&gt;&#10;                            &lt;li&gt;Use Ctrl + Left Click to pan the image and Ctrl + Mouse Wheel to zoom.&lt;/li&gt;&#10;                        &lt;/ul&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;row&quot;&gt;&#10;        &lt;div class=&quot;col-md-9&quot;&gt;&#10;            &lt;div class=&quot;card&quot;&gt;&#10;                &lt;h5 class=&quot;card-header&quot;&gt;Interactive View (Mode: biplot)&lt;/h5&gt;&#10;                &lt;div class=&quot;card-body&quot;&gt;&#10;                    &lt;div class=&quot;btn-group mb-2&quot;&gt;&#10;                        &lt;button onclick=&quot;zoomIn()&quot; class=&quot;btn btn-light btn-sm&quot;&gt;Zoom In&lt;/button&gt;&#10;                        &lt;button onclick=&quot;zoomOut()&quot; class=&quot;btn btn-light btn-sm&quot;&gt;Zoom Out&lt;/button&gt;&#10;                        &lt;button onclick=&quot;resetZoom()&quot; class=&quot;btn btn-light btn-sm&quot;&gt;Reset View&lt;/button&gt;&#10;                        &lt;span&gt;Zoom: &lt;span id=&quot;zoom-display&quot;&gt;100%&lt;/span&gt;&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;div id=&quot;image-container&quot; class=&quot;border rounded overflow-auto&quot; style=&quot;height: 70vh;&quot;&gt;&#10;                        &lt;div id=&quot;zoom-scene&quot;&gt;&#10;                            &lt;img id=&quot;plot-image&quot; src=&quot;/uploaded_images/{{ uploaded_image.image }}&quot; alt=&quot;Uploaded Image&quot; onclick=&quot;handleImageClick(event)&quot; class=&quot;img-fluid&quot;&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;col-md-3&quot;&gt;&#10;            &lt;div class=&quot;card&quot;&gt;&#10;                &lt;h5 class=&quot;card-header&quot;&gt;Extracted Data&lt;/h5&gt;&#10;                &lt;div class=&quot;card-body&quot;&gt;&#10;                    &lt;form class=&quot;mb-2&quot;&gt;&#10;                        &lt;label&gt;Var1:&lt;/label&gt;&#10;                        &lt;select id=&quot;angle-var1&quot; class=&quot;form-select form-select-sm d-inline-block w-auto&quot;&gt;&lt;/select&gt;&#10;                        &lt;label&gt;Var2:&lt;/label&gt;&#10;                        &lt;select id=&quot;angle-var2&quot; class=&quot;form-select form-select-sm d-inline-block w-auto&quot;&gt;&lt;/select&gt;&#10;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-secondary&quot; onclick=&quot;calculateSelectedAngle()&quot;&gt;Get Angle&lt;/button&gt;&#10;                    &lt;/form&gt;&#10;                    &lt;div id=&quot;angle-result&quot; class=&quot;mb-2&quot;&gt;&lt;/div&gt;&#10;                    &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt;&#10;                        &lt;thead&gt;&#10;                            &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Variable&lt;/th&gt;&lt;th&gt;PC1&lt;/th&gt;&lt;th&gt;PC2&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;/tr&gt;&#10;                        &lt;/thead&gt;&#10;                        &lt;tbody id=&quot;data-table-body&quot;&gt;&lt;/tbody&gt;&#10;                    &lt;/table&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;row&quot;&gt;&#10;        &lt;div class=&quot;col-12 mb-3&quot;&gt;&#10;            &lt;div class=&quot;btn-group&quot;&gt;&#10;                &lt;button onclick=&quot;resetCalibration()&quot; class=&quot;btn btn-outline-danger&quot;&gt;Reset All&lt;/button&gt;&#10;                &lt;button onclick=&quot;clearArrows()&quot; class=&quot;btn btn-outline-danger&quot;&gt;Clear Arrows&lt;/button&gt;&#10;                &lt;button onclick=&quot;saveResults()&quot; class=&quot;btn btn-primary&quot;&gt;Save Results&lt;/button&gt;&#10;                &lt;button onclick=&quot;exportToCSV()&quot; class=&quot;btn btn-primary&quot;&gt;Export to CSV&lt;/button&gt;&#10;            &lt;/div&gt;&#10;            &lt;br&gt;&lt;br&gt;&#10;            &lt;div class=&quot;info-block&quot;&gt;&#10;                &lt;span&gt;&lt;strong&gt;Calibration Details:&lt;/strong&gt;&lt;/span&gt;&#10;                &lt;span&gt;X1: &lt;span id=&quot;calibration-x1&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;X2: &lt;span id=&quot;calibration-x2&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;Y1: &lt;span id=&quot;calibration-y1&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;Y2: &lt;span id=&quot;calibration-y2&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;                &lt;span&gt;Center: &lt;span id=&quot;calibration-center&quot;&gt;N/A&lt;/span&gt;&lt;/span&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;script&gt;&#10;    const existingAnalysis = {{ existing_analysis|default:'{}'|safe }};&#10;    let calibration = { x: [], y: [], center: null };&#10;    let calibratedValues = { x: null, y: null };&#10;    let centerReal = null;&#10;    let isCalibratingAxes = false;&#10;    let isCalibratingCenter = false;&#10;    let isAddingArrows = false;&#10;    let extractedArrows = [];&#10;    let zoomLevel = 1, panX = 0, panY = 0, isDragging = false, lastMouseX = 0, lastMouseY = 0;&#10;&#10;    function handleImageClick(event) {&#10;        if (isDragging) return;&#10;        if (isCalibratingAxes) {&#10;            const img = document.querySelector('#plot-image');&#10;            const rect = img.getBoundingClientRect();&#10;            const relativeX = (event.clientX - rect.left) / rect.width;&#10;            const relativeY = (event.clientY - rect.top) / rect.height;&#10;            const originalX = relativeX * img.naturalWidth;&#10;            const originalY = relativeY * img.naturalHeight;&#10;            if (calibration.x.length &lt; 2) {&#10;                calibration.x.push({ x: originalX, y: originalY, relativeX, relativeY });&#10;                renderGreenDot(relativeX, relativeY, 'X' + calibration.x.length);&#10;                const val = prompt('Enter PC1 value for this point:'); if (val!==null) calibration.x[calibration.x.length-1].value = parseFloat(val);&#10;            } else if (calibration.y.length &lt; 2) {&#10;                calibration.y.push({ x: originalX, y: originalY, relativeX, relativeY });&#10;                renderGreenDot(relativeX, relativeY, 'Y' + calibration.y.length);&#10;                const val = prompt('Enter PC2 value for this point:'); if (val!==null) calibration.y[calibration.y.length-1].value = parseFloat(val);&#10;            }&#10;            if (calibration.x.length===2 &amp;&amp; calibration.y.length===2) {&#10;                isCalibratingAxes = false;&#10;                calculateCalibration();&#10;                updateCalibrationInfo();&#10;                alert('Axes calibration complete');&#10;            }&#10;        } else if (isCalibratingCenter) {&#10;            const img = document.querySelector('#plot-image');&#10;            const rect = img.getBoundingClientRect();&#10;            const relativeX = (event.clientX - rect.left) / rect.width;&#10;            const relativeY = (event.clientY - rect.top) / rect.height;&#10;            const originalX = relativeX * img.naturalWidth;&#10;            const originalY = relativeY * img.naturalHeight;&#10;            calibration.center = { x: originalX, y: originalY, relativeX, relativeY };&#10;            renderGreenDot(relativeX, relativeY, 'Center');&#10;            centerReal = calculateRealValues(originalX, originalY);&#10;            isCalibratingCenter = false;&#10;            alert('Center marked');&#10;        } else if (isAddingArrows) {&#10;            if (!centerReal) { alert('Please calibrate axes and center first'); return; }&#10;            const img = document.querySelector('#plot-image');&#10;            const rect = img.getBoundingClientRect();&#10;            const relativeX = (event.clientX - rect.left) / rect.width;&#10;            const relativeY = (event.clientY - rect.top) / rect.height;&#10;            const originalX = relativeX * img.naturalWidth;&#10;            const originalY = relativeY * img.naturalHeight;&#10;            const real = calculateRealValues(originalX, originalY);&#10;            const loadingX = real.x - centerReal.x;&#10;            const loadingY = real.y - centerReal.y;&#10;            const name = prompt('Enter variable name:'); if (!name) return;&#10;            const dot = renderRedDot(relativeX, relativeY);&#10;            const lineEl = renderArrowLine(originalX, originalY);&#10;            extractedArrows.push({ name, loadingX, loadingY, relativeX, relativeY, dotElement: dot, lineElement: lineEl });&#10;            updateDataTable();&#10;            if (extractedArrows.length&gt;1) {&#10;                const prev = extractedArrows[extractedArrows.length-2]; const curr = extractedArrows[extractedArrows.length-1];&#10;                const angle = calculateAngle({x:prev.loadingX,y:prev.loadingY},{x:curr.loadingX,y:curr.loadingY});&#10;                alert(`Angle between ${prev.name} and ${curr.name}: ${angle.toFixed(2)}°`);&#10;            }&#10;        }&#10;    }&#10;&#10;    function calculateCalibration() {&#10;        calibratedValues.x = (calibration.x[1].value - calibration.x[0].value) / (calibration.x[1].x - calibration.x[0].x);&#10;        calibratedValues.y = (calibration.y[1].value - calibration.y[0].value) / (calibration.y[1].y - calibration.y[0].y);&#10;    }&#10;    function calculateRealValues(origX, origY) {&#10;        const realX = calibration.x[0].value + (origX - calibration.x[0].x) * calibratedValues.x;&#10;        const realY = calibration.y[0].value + (origY - calibration.y[0].y) * calibratedValues.y;&#10;        return { x: realX, y: realY };&#10;    }&#10;    function calculateAngle(v1, v2) {&#10;        const dot = v1.x * v2.x + v1.y * v2.y;&#10;        const mag1 = Math.hypot(v1.x, v1.y);&#10;        const mag2 = Math.hypot(v2.x, v2.y);&#10;        return Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);&#10;    }&#10;    function renderGreenDot(relX, relY, label) {&#10;        const container = document.querySelector('#zoom-scene');&#10;        const dot = document.createElement('div'); dot.className = 'data-dot green-dot';&#10;        dot.style.left = `${relX * 100}%`; dot.style.top = `${relY * 100}%`;&#10;        if (label) { const lb = document.createElement('span'); lb.className = 'dot-label'; lb.textContent = label; dot.appendChild(lb); }&#10;        container.appendChild(dot);&#10;    }&#10;    function renderRedDot(relX, relY) {&#10;        const container = document.querySelector('#zoom-scene');&#10;        const dot = document.createElement('div'); dot.className = 'data-dot red-dot';&#10;        dot.style.left = `${relX * 100}%`; dot.style.top = `${relY * 100}%`;&#10;        container.appendChild(dot); return dot;&#10;    }&#10;    function renderArrowLine(origX, origY) {&#10;        const svg = document.getElementById('arrow-layer');&#10;        const line = document.createElementNS('http://www.w3.org/2000/svg','line');&#10;        line.setAttribute('x1', calibration.center.x);&#10;        line.setAttribute('y1', calibration.center.y);&#10;        line.setAttribute('x2', origX);&#10;        line.setAttribute('y2', origY);&#10;        line.setAttribute('stroke', 'red');&#10;        line.setAttribute('stroke-width', '2');&#10;        svg.appendChild(line);&#10;        return line;&#10;    }&#10;    function updateDataTable() {&#10;        const tbody = document.getElementById('data-table-body'); tbody.innerHTML = '';&#10;        extractedArrows.forEach((d, i) =&gt; {&#10;            const tr = document.createElement('tr');&#10;            tr.innerHTML = `&lt;td&gt;${i+1}&lt;/td&gt;&lt;td&gt;${d.name}&lt;/td&gt;&lt;td&gt;${d.loadingX.toFixed(2)}&lt;/td&gt;&lt;td&gt;${d.loadingY.toFixed(2)}&lt;/td&gt;&lt;td&gt;&lt;a href='#' onclick=&quot;deleteArrow(${i})&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;`;&#10;            tr.addEventListener('click', () =&gt; highlightArrow(i));&#10;            tbody.appendChild(tr);&#10;        });&#10;        updateAngleSelectors();&#10;    }&#10;    function updateAngleSelectors() {&#10;        const s1 = document.getElementById('angle-var1');&#10;        const s2 = document.getElementById('angle-var2');&#10;        s1.innerHTML = '&lt;option value=&quot;&quot;&gt;Select&lt;/option&gt;';&#10;        s2.innerHTML = '&lt;option value=&quot;&quot;&gt;Select&lt;/option&gt;';&#10;        extractedArrows.forEach(d =&gt; {&#10;            const opt1 = document.createElement('option'); opt1.value = d.name; opt1.textContent = d.name;&#10;            const opt2 = opt1.cloneNode(true);&#10;            s1.appendChild(opt1); s2.appendChild(opt2);&#10;        });&#10;    }&#10;    function calculateSelectedAngle() {&#10;        const v1 = document.getElementById('angle-var1').value;&#10;        const v2 = document.getElementById('angle-var2').value;&#10;        if (!v1 || !v2) { alert('Select both variables'); return; }&#10;        const o1 = extractedArrows.find(d =&gt; d.name === v1);&#10;        const o2 = extractedArrows.find(d =&gt; d.name === v2);&#10;        const ang = calculateAngle({x:o1.loadingX, y:o1.loadingY}, {x:o2.loadingX, y:o2.loadingY});&#10;        document.getElementById('angle-result').textContent = `Angle between ${v1} and ${v2}: ${ang.toFixed(2)}°`;&#10;    }&#10;    function deleteArrow(idx) {&#10;        if (extractedArrows[idx].dotElement) extractedArrows[idx].dotElement.remove();&#10;        if (extractedArrows[idx].lineElement) extractedArrows[idx].lineElement.remove();&#10;        extractedArrows.splice(idx,1); updateDataTable();&#10;    }&#10;    function highlightArrow(idx) {&#10;        const data = extractedArrows[idx];&#10;        const hl = document.createElement('div'); hl.className='data-dot highlight-dot';&#10;        hl.style.left=`${data.relativeX*100}%`; hl.style.top=`${data.relativeY*100}%`;&#10;        document.querySelector('#zoom-scene').appendChild(hl);&#10;        setTimeout(()=&gt;hl.remove(),1000);&#10;    }&#10;    function startAxesCalibration() { isCalibratingAxes=true; isCalibratingCenter=false; isAddingArrows=false; calibration={x:[],y:[],center:null}; existingAnalysis; document.querySelectorAll('.data-dot').forEach(el=&gt;el.remove()); updateCalibrationInfo(); alert('Select two X-axis points and two Y-axis points'); }&#10;    function startCenterCalibration() { if (!calibratedValues.x) { alert('Calibrate axes first'); return;} isCalibratingCenter=true; isCalibratingAxes=false; isAddingArrows=false; alert('Select center point'); }&#10;    function startAddingArrows() { if (!centerReal) { alert('Mark center first'); return;} isAddingArrows=true; isCalibratingAxes=false; isCalibratingCenter=false; alert('Click arrow tips to add variables'); }&#10;    function updateCalibrationInfo() {&#10;        document.getElementById('calibration-x1').textContent = calibration.x[0]?.value||'N/A';&#10;        document.getElementById('calibration-x2').textContent = calibration.x[1]?.value||'N/A';&#10;        document.getElementById('calibration-y1').textContent = calibration.y[0]?.value||'N/A';&#10;        document.getElementById('calibration-y2').textContent = calibration.y[1]?.value||'N/A';&#10;        document.getElementById('calibration-center').textContent = centerReal?`(${centerReal.x.toFixed(2)},${centerReal.y.toFixed(2)})`:'N/A';&#10;    }&#10;    function resetCalibration() { calibration={x:[],y:[],center:null}; calibratedValues={x:null,y:null}; centerReal=null; isCalibratingAxes=isCalibratingCenter=isAddingArrows=false; document.querySelectorAll('.data-dot').forEach(el=&gt;el.remove()); extractedArrows=[]; updateDataTable(); updateCalibrationInfo(); }&#10;    function clearArrows() { extractedArrows.forEach(d=&gt;{ if (d.dotElement) d.dotElement.remove(); if (d.lineElement) d.lineElement.remove(); }); extractedArrows=[]; updateDataTable(); }&#10;    function exportToCSV() { const rows=['Variable,PC1,PC2']; extractedArrows.forEach((d,i)=&gt;rows.push(`${d.name},${d.loadingX.toFixed(2)},${d.loadingY.toFixed(2)}`)); const blob=new Blob([rows.join('\n')],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='biplot_data.csv'; a.click(); URL.revokeObjectURL(url); }&#10;    function saveResults() { fetch('',{method:'POST',headers:{'Content-Type':'application/json','X-CSRFToken':'{{ csrf_token }}'},body:JSON.stringify({saveResults:true,calibration,extractedData:extractedArrows})}).then(r=&gt;r.json()).then(d=&gt;alert(d.message||'Saved')); }&#10;    function zoomIn(){zoomLevel=Math.min(zoomLevel*1.5,5);updateImageTransform();}&#10;    function zoomOut(){zoomLevel=Math.max(zoomLevel/1.5,0.5);updateImageTransform();}&#10;    function resetZoom(){zoomLevel=1;panX=0;panY=0;updateImageTransform();}&#10;    function updateImageTransform(){const s=document.querySelector('#zoom-scene');s.style.transform=`scale(${zoomLevel}) translate(${panX}px,${panY}px)`;document.getElementById('zoom-display').textContent=Math.round(zoomLevel*100)+'%';}&#10;    function handleMouseDown(e){if(e.button===0&amp;&amp;e.ctrlKey){isDragging=true;lastMouseX=e.clientX;lastMouseY=e.clientY; e.preventDefault();}}&#10;    function handleMouseMove(e){if(isDragging){const dx=e.clientX-lastMouseX,dy=e.clientY-lastMouseY;panX+=dx/zoomLevel;panY+=dy/zoomLevel;updateImageTransform();lastMouseX=e.clientX;lastMouseY=e.clientY;}}&#10;    function handleMouseUp(){isDragging=false;}&#10;    function handleWheel(e){if(e.ctrlKey){e.preventDefault();e.deltaY&lt;0?zoomIn():zoomOut();}}&#10;    document.addEventListener('DOMContentLoaded',()=&gt;{&#10;        const ic=document.querySelector('#image-container');ic.addEventListener('mousedown',handleMouseDown);document.addEventListener('mousemove',handleMouseMove);document.addEventListener('mouseup',handleMouseUp);ic.addEventListener('wheel',handleWheel);&#10;        // add SVG overlay for arrows&#10;        const img = document.querySelector('#plot-image');&#10;        const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');&#10;        svg.setAttribute('id','arrow-layer');&#10;        svg.setAttribute('viewBox', `0 0 ${img.naturalWidth} ${img.naturalHeight}`);&#10;        svg.style.position = 'absolute'; svg.style.top = '0'; svg.style.left = '0';&#10;        svg.style.width = '100%'; svg.style.height = '100%'; svg.style.pointerEvents = 'none';&#10;        document.querySelector('#zoom-scene').appendChild(svg);&#10;        // render existing arrows with lines&#10;        if(existingAnalysis.extractedData){&#10;            existingAnalysis.extractedData.forEach((pt, i) =&gt; {&#10;                const dot = renderRedDot(pt.relativeX, pt.relativeY);&#10;                const origX = pt.relativeX * img.naturalWidth;&#10;                const origY = pt.relativeY * img.naturalHeight;&#10;                const line = renderArrowLine(origX, origY);&#10;                extractedArrows.push({...pt, dotElement: dot, lineElement: line});&#10;            });&#10;            updateDataTable();&#10;        }&#10;        if(existingAnalysis.calibration){ calibration=existingAnalysis.calibration; calibration.center=existingAnalysis.calibration.center; calculateCalibration(); centerReal=calculateRealValues(calibration.center.x,calibration.center.y); calibration.x.forEach((pt,i)=&gt;renderGreenDot(pt.relativeX,pt.relativeY,'X'+(i+1))); calibration.y.forEach((pt,i)=&gt;renderGreenDot(pt.relativeX,pt.relativeY,'Y'+(i+1))); renderGreenDot(calibration.center.relativeX,calibration.center.relativeY,'Center'); updateCalibrationInfo(); }&#10;    });&#10;&lt;/script&gt;&#10;&lt;style&gt;&#10;    #image-container{position:relative;overflow:auto;border:2px solid #ddd;max-width:100%;max-height:70vh;cursor:crosshair;}&#10;    #zoom-scene{position:relative;transform-origin:top left;transition:transform .1s ease-out;width:fit-content;height:fit-content;}&#10;    #plot-image{display:block;max-width:none;max-height:none;transform-origin:top left;transition:transform .1s ease-out;}&#10;    .data-dot{position:absolute;border-radius:50%;pointer-events:none;transform:translate(-50%,-50%);z-index:10;}&#10;    .red-dot{width:8px;height:8px;background-color:#B02226;border:1px solid whitesmoke;}&#10;    .green-dot{width:10px;height:10px;background-color:#38C1F3;border:1px solid whitesmoke;}&#10;    .highlight-dot{width:15px;height:15px;background-color:#F0A12C;border:2px solid whitesmoke;animation:pulse .5s ease-in-out;}&#10;    @keyframes pulse{0%{transform:translate(-50%,-50%) scale(1);}50%{transform:translate(-50%,-50%) scale(1.5);}100%{transform:translate(-50%,-50%) scale(1);} }&#10;    .dot-label{position:absolute;top:-20px;left:50%;transform:translateX(-50%);background:white;padding:2px 4px;border:1px solid #ccc;border-radius:3px;font-size:12px;}&#10;&lt;/style&gt;&#10;{% endblock %}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Mainapp/templates/manage_figures.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Mainapp/templates/manage_figures.html" />
              <option name="originalContent" value="{% extends 'master.html' %}&#10;&#10;{% block title %}Manage Figures{% endblock %}&#10;&#10;{% block content %}&#10;&lt;div class=&quot;container&quot;&gt;&#10;    &lt;h2&gt;Manage&lt;/h2&gt;&#10;    &lt;table class=&quot;table table-striped&quot;&gt;&#10;        &lt;thead&gt;&#10;            &lt;tr&gt;&#10;                &lt;th&gt;ID&lt;/th&gt;&#10;                &lt;th&gt;Preview&lt;/th&gt;&#10;                &lt;th&gt;Note&lt;/th&gt;&#10;                &lt;th&gt;Actions&lt;/th&gt;&#10;            &lt;/tr&gt;&#10;        &lt;/thead&gt;&#10;        &lt;tbody&gt;&#10;            {% for figure in figures %}&#10;            &lt;tr id=&quot;row-{{ figure.id }}&quot;&gt;&#10;                &lt;td&gt;{{ figure.id }}&lt;/td&gt;&#10;                &lt;td&gt;&lt;img src=&quot;/uploaded_images/{{ figure.image }}&quot; alt=&quot;Figure Preview&quot; style=&quot;max-width: 100px; max-height: 100px;&quot;&gt;&lt;/td&gt;&#10;                &lt;td&gt;&#10;                    &lt;input type=&quot;text&quot; id=&quot;note-{{ figure.id }}&quot; value=&quot;{{ figure.note|default:'' }}&quot; class=&quot;form-control mb-2&quot; placeholder=&quot;Add Note&quot;&gt;&#10;                    &lt;select id=&quot;category-{{ figure.id }}&quot; class=&quot;form-select mb-2&quot; onchange=&quot;saveChanges({{ figure.id }})&quot;&gt;&#10;                        &lt;option value=&quot;&quot; {% if not figure.category %}selected{% endif %}&gt;Select Category&lt;/option&gt;&#10;                        &lt;option value=&quot;scatterplot&quot; {% if figure.category == 'scatterplot' %}selected{% endif %}&gt;Scatterplot&lt;/option&gt;&#10;                        &lt;option value=&quot;barplot&quot; {% if figure.category == 'barplot' %}selected{% endif %}&gt;Barplot&lt;/option&gt;&#10;                        &lt;!-- More types --&gt;&#10;                    &lt;/select&gt;&#10;                &lt;/td&gt;&#10;                &lt;td&gt;&#10;                    &lt;a class=&quot;btn btn-primary&quot; href=&quot;#&quot; onclick=&quot;validateAndAnalyze({{ figure.id }})&quot;&gt;Analyze&lt;/a&gt;&#10;                    &lt;button class=&quot;btn btn-primary me-2&quot; onclick=&quot;saveChanges({{ figure.id }})&quot;&gt;Save Changes&lt;/button&gt;&#10;                    &lt;button class=&quot;btn btn-danger&quot; onclick=&quot;deleteFigure({{ figure.id }})&quot;&gt;Delete&lt;/button&gt;&#10;                &lt;/td&gt;&#10;            &lt;/tr&gt;&#10;            {% endfor %}&#10;        &lt;/tbody&gt;&#10;    &lt;/table&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;script&gt;&#10;    function saveChanges(figureId) {&#10;        const note = document.getElementById(`note-${figureId}`).value;&#10;        const category = document.getElementById(`category-${figureId}`).value;&#10;&#10;        fetch('', {&#10;            method: 'POST',&#10;            headers: {&#10;                'Content-Type': 'application/json',&#10;                'X-CSRFToken': '{{ csrf_token }}'&#10;            },&#10;            body: JSON.stringify({&#10;                figure_id: figureId,&#10;                note: note,&#10;                category: category&#10;            })&#10;        })&#10;        .then(response =&gt; response.json())&#10;        .then(data =&gt; {&#10;            if (data.status === 'success') {&#10;                // alert(data.message);&#10;            } else {&#10;                alert('Error: ' + data.message);&#10;            }&#10;        });&#10;    }&#10;&#10;    function validateAndAnalyze(figureId) {&#10;        const category = document.getElementById(`category-${figureId}`).value;&#10;        if (!category) {&#10;            alert('Please select a category before analyzing.');&#10;            return;&#10;        }&#10;        window.location.href = `/interactive/${figureId}`;&#10;    }&#10;&#10;    function deleteFigure(figureId) {&#10;        const confirmation = prompt('Type DELETE to confirm deletion of this figure and its analysis:');&#10;        if (confirmation !== 'DELETE') {&#10;            alert('Deletion cancelled.');&#10;            return;&#10;        }&#10;&#10;        fetch(&quot;&quot;, {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;                &quot;X-CSRFToken&quot;: &quot;{{ csrf_token }}&quot;&#10;            },&#10;            body: JSON.stringify({ delete_id: figureId })&#10;        })&#10;        .then(response =&gt; response.json())&#10;        .then(data =&gt; {&#10;            if (data.status === 'success') {&#10;                document.getElementById(`row-${figureId}`).remove();&#10;                alert('Figure and its analysis have been deleted successfully.');&#10;            } else {&#10;                alert('Error: ' + data.message);&#10;            }&#10;        })&#10;        .catch(error =&gt; console.error('Error:', error));&#10;    }&#10;&lt;/script&gt;&#10;{% endblock %}&#10;" />
              <option name="updatedContent" value="{% extends 'master.html' %}&#13;&#10;&#13;&#10;{% block title %}Manage Figures{% endblock %}&#13;&#10;&#13;&#10;{% block content %}&#13;&#10;&lt;div class=&quot;container&quot;&gt;&#13;&#10;    &lt;h2&gt;Manage&lt;/h2&gt;&#13;&#10;    &lt;table class=&quot;table table-striped&quot;&gt;&#13;&#10;        &lt;thead&gt;&#13;&#10;            &lt;tr&gt;&#13;&#10;                &lt;th&gt;ID&lt;/th&gt;&#13;&#10;                &lt;th&gt;Preview&lt;/th&gt;&#13;&#10;                &lt;th&gt;Note&lt;/th&gt;&#13;&#10;                &lt;th&gt;Actions&lt;/th&gt;&#13;&#10;            &lt;/tr&gt;&#13;&#10;        &lt;/thead&gt;&#13;&#10;        &lt;tbody&gt;&#13;&#10;            {% for figure in figures %}&#13;&#10;            &lt;tr id=&quot;row-{{ figure.id }}&quot;&gt;&#13;&#10;                &lt;td&gt;{{ figure.id }}&lt;/td&gt;&#13;&#10;                &lt;td&gt;&lt;img src=&quot;/uploaded_images/{{ figure.image }}&quot; alt=&quot;Figure Preview&quot; style=&quot;max-width: 100px; max-height: 100px;&quot;&gt;&lt;/td&gt;&#13;&#10;                &lt;td&gt;&#13;&#10;                    &lt;input type=&quot;text&quot; id=&quot;note-{{ figure.id }}&quot; value=&quot;{{ figure.note|default:'' }}&quot; class=&quot;form-control mb-2&quot; placeholder=&quot;Add Note&quot;&gt;&#13;&#10;                    &lt;select id=&quot;category-{{ figure.id }}&quot; class=&quot;form-select mb-2&quot; onchange=&quot;saveChanges({{ figure.id }})&quot;&gt;&#13;&#10;                        &lt;option value=&quot;&quot; {% if not figure.category %}selected{% endif %}&gt;Select Category&lt;/option&gt;&#13;&#10;                        &lt;option value=&quot;scatterplot&quot; {% if figure.category == 'scatterplot' %}selected{% endif %}&gt;Scatterplot&lt;/option&gt;&#13;&#10;                        &lt;option value=&quot;barplot&quot; {% if figure.category == 'barplot' %}selected{% endif %}&gt;Barplot&lt;/option&gt;&#13;&#10;                        &lt;option value=&quot;biplot&quot; {% if figure.category == 'biplot' %}selected{% endif %}&gt;Biplot&lt;/option&gt;&#13;&#10;                        &lt;!-- More types --&gt;&#13;&#10;                    &lt;/select&gt;&#13;&#10;                &lt;/td&gt;&#13;&#10;                &lt;td&gt;&#13;&#10;                    &lt;a class=&quot;btn btn-primary&quot; href=&quot;#&quot; onclick=&quot;validateAndAnalyze({{ figure.id }})&quot;&gt;Analyze&lt;/a&gt;&#13;&#10;                    &lt;button class=&quot;btn btn-primary me-2&quot; onclick=&quot;saveChanges({{ figure.id }})&quot;&gt;Save Changes&lt;/button&gt;&#13;&#10;                    &lt;button class=&quot;btn btn-danger&quot; onclick=&quot;deleteFigure({{ figure.id }})&quot;&gt;Delete&lt;/button&gt;&#13;&#10;                &lt;/td&gt;&#13;&#10;            &lt;/tr&gt;&#13;&#10;            {% endfor %}&#13;&#10;        &lt;/tbody&gt;&#13;&#10;    &lt;/table&gt;&#13;&#10;&lt;/div&gt;&#13;&#10;&#13;&#10;&lt;script&gt;&#13;&#10;    function saveChanges(figureId) {&#13;&#10;        const note = document.getElementById(`note-${figureId}`).value;&#13;&#10;        const category = document.getElementById(`category-${figureId}`).value;&#13;&#10;&#13;&#10;        fetch('', {&#13;&#10;            method: 'POST',&#13;&#10;            headers: {&#13;&#10;                'Content-Type': 'application/json',&#13;&#10;                'X-CSRFToken': '{{ csrf_token }}'&#13;&#10;            },&#13;&#10;            body: JSON.stringify({&#13;&#10;                figure_id: figureId,&#13;&#10;                note: note,&#13;&#10;                category: category&#13;&#10;            })&#13;&#10;        })&#13;&#10;        .then(response =&gt; response.json())&#13;&#10;        .then(data =&gt; {&#13;&#10;            if (data.status === 'success') {&#13;&#10;                // alert(data.message);&#13;&#10;            } else {&#13;&#10;                alert('Error: ' + data.message);&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    function validateAndAnalyze(figureId) {&#13;&#10;        const category = document.getElementById(`category-${figureId}`).value;&#13;&#10;        if (!category) {&#13;&#10;            alert('Please select a category before analyzing.');&#13;&#10;            return;&#13;&#10;        }&#13;&#10;        window.location.href = `/interactive/${figureId}`;&#13;&#10;    }&#13;&#10;&#13;&#10;    function deleteFigure(figureId) {&#13;&#10;        const confirmation = prompt('Type DELETE to confirm deletion of this figure and its analysis:');&#13;&#10;        if (confirmation !== 'DELETE') {&#13;&#10;            alert('Deletion cancelled.');&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        fetch(&quot;&quot;, {&#13;&#10;            method: &quot;POST&quot;,&#13;&#10;            headers: {&#13;&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;,&#13;&#10;                &quot;X-CSRFToken&quot;: &quot;{{ csrf_token }}&quot;&#13;&#10;            },&#13;&#10;            body: JSON.stringify({ delete_id: figureId })&#13;&#10;        })&#13;&#10;        .then(response =&gt; response.json())&#13;&#10;        .then(data =&gt; {&#13;&#10;            if (data.status === 'success') {&#13;&#10;                document.getElementById(`row-${figureId}`).remove();&#13;&#10;                alert('Figure and its analysis have been deleted successfully.');&#13;&#10;            } else {&#13;&#10;                alert('Error: ' + data.message);&#13;&#10;            }&#13;&#10;        })&#13;&#10;        .catch(error =&gt; console.error('Error:', error));&#13;&#10;    }&#13;&#10;&lt;/script&gt;&#13;&#10;{% endblock %}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Mainapp/views.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Mainapp/views.py" />
              <option name="originalContent" value="from django.shortcuts import render, redirect&#10;from .models import UploadedImage&#10;from django.core.files.storage import FileSystemStorage&#10;from django.views import View&#10;from django.http import HttpRequest, JsonResponse&#10;from django.urls import reverse&#10;import json&#10;import os&#10;from django.conf import settings&#10;&#10;class HomeView(View):&#10;    def get(self, request: HttpRequest):&#10;        return render(request, 'home.html')&#10;&#10;    def post(self, request: HttpRequest):&#10;        # Handle any form submissions or data processing here&#10;        return redirect('upload_image')&#10;&#10;class UploadImageView(View):&#10;    def get(self, request: HttpRequest):&#10;        return render(request, 'upload_image.html')&#10;&#10;    def post(self, request: HttpRequest):&#10;        image_file = request.FILES.get('image')&#10;        if image_file:&#10;            fs = FileSystemStorage(location='uploaded_images/')&#10;            filename = fs.save(image_file.name, image_file)&#10;            uploaded_image = UploadedImage.objects.create(image=filename)&#10;            # Jump to manage page after upload&#10;            return redirect(reverse('manage_figures'))&#10;        return render(request, 'upload_image.html')&#10;&#10;class InteractiveView(View):&#10;    def get(self, request: HttpRequest, image_id: int):&#10;        try:&#10;            uploaded_image = UploadedImage.objects.get(id=image_id)&#10;            # load existing analysis JSON if present&#10;            analysis_dir = os.path.join(settings.BASE_DIR, 'analysis_results')&#10;            json_path = os.path.join(analysis_dir, f'figure_{image_id}.json')&#10;            existing_analysis = {}&#10;            if os.path.exists(json_path):&#10;                with open(json_path, 'r') as f:&#10;                    existing_analysis = json.load(f)&#10;            # Load the appropriate template based on the category&#10;            if uploaded_image.category == 'barplot':&#10;                template_name = 'interactive_barplot.html'&#10;            else:&#10;                template_name = 'interactive_scatter.html'&#10;            return render(request, template_name, {&#10;                'uploaded_image': uploaded_image,&#10;                'existing_analysis': existing_analysis&#10;            })&#10;        except UploadedImage.DoesNotExist:&#10;            return redirect('upload_image')&#10;&#10;    def post(self, request: HttpRequest, image_id: int):&#10;        try:&#10;            data = json.loads(request.body)&#10;            # handle save results&#10;            if data.get('saveResults'):&#10;                analysis_dir = os.path.join(settings.BASE_DIR, 'analysis_results')&#10;                os.makedirs(analysis_dir, exist_ok=True)&#10;                json_path = os.path.join(analysis_dir, f'figure_{image_id}.json')&#10;                with open(json_path, 'w') as f:&#10;                    json.dump({'calibration': data.get('calibration', []), 'extractedData': data.get('extractedData', [])}, f)&#10;                return JsonResponse({'status': 'success', 'message': 'Analysis saved'})&#10;            # calibration and extracted handling unchanged&#10;            if 'calibration' in data:&#10;                # Handle calibration data&#10;                calibration_data = data['calibration']&#10;                print(&quot;Calibration data received:&quot;, calibration_data)&#10;                return JsonResponse({'status': 'success', 'message': 'Calibration data processed'})&#10;&#10;            if 'extractedData' in data:&#10;                # Handle extracted data points&#10;                extracted_data = data['extractedData']&#10;                print(&quot;Extracted data received:&quot;, extracted_data)&#10;                return JsonResponse({'status': 'success', 'message': 'Extracted data processed'})&#10;&#10;        except json.JSONDecodeError:&#10;            return JsonResponse({'status': 'error', 'message': 'Invalid JSON data'}, status=400)&#10;&#10;        return JsonResponse({'status': 'error', 'message': 'Invalid request'}, status=400)&#10;&#10;class ManageFiguresView(View):&#10;    def get(self, request: HttpRequest):&#10;        figures = UploadedImage.objects.all()&#10;        return render(request, 'manage_figures.html', {'figures': figures})&#10;&#10;    def post(self, request: HttpRequest):&#10;        data = json.loads(request.body)&#10;        if data.get('delete_id'):&#10;            fid = data['delete_id']&#10;            try:&#10;                figure = UploadedImage.objects.get(id=fid)&#10;                # Delete the figure file&#10;                if figure.image:&#10;                    figure.image.delete(save=False)&#10;                # Remove associated JSON file&#10;                analysis_dir = os.path.join(settings.BASE_DIR, 'analysis_results')&#10;                json_path = os.path.join(analysis_dir, f'figure_{fid}.json')&#10;                if os.path.exists(json_path):&#10;                    os.remove(json_path)&#10;                # Delete the database record&#10;                figure.delete()&#10;                return JsonResponse({'status': 'success', 'message': 'Figure and its analysis deleted successfully'})&#10;            except UploadedImage.DoesNotExist:&#10;                return JsonResponse({'status': 'error', 'message': 'Figure not found'}, status=404)&#10;        elif data.get('figure_id'):&#10;            fid = data['figure_id']&#10;            note = data.get('note', None)&#10;            category = data.get('category', None)&#10;            try:&#10;                figure = UploadedImage.objects.get(id=fid)&#10;                if note is not None:&#10;                    figure.note = note&#10;                if category is not None:&#10;                    figure.category = category&#10;                figure.save()&#10;                return JsonResponse({'status': 'success', 'message': 'Note/Category updated'})&#10;            except UploadedImage.DoesNotExist:&#10;                return JsonResponse({'status': 'error', 'message': 'Figure not found'}, status=404)&#10;        return JsonResponse({'status': 'error', 'message': 'Invalid request'}, status=400)&#10;" />
              <option name="updatedContent" value="from django.shortcuts import render, redirect&#10;from .models import UploadedImage&#10;from django.core.files.storage import FileSystemStorage&#10;from django.views import View&#10;from django.http import HttpRequest, JsonResponse&#10;from django.urls import reverse&#10;import json&#10;import os&#10;from django.conf import settings&#10;&#10;class HomeView(View):&#10;    def get(self, request: HttpRequest):&#10;        return render(request, 'home.html')&#10;&#10;    def post(self, request: HttpRequest):&#10;        # Handle any form submissions or data processing here&#10;        return redirect('upload_image')&#10;&#10;class UploadImageView(View):&#10;    def get(self, request: HttpRequest):&#10;        return render(request, 'upload_image.html')&#10;&#10;    def post(self, request: HttpRequest):&#10;        image_file = request.FILES.get('image')&#10;        if image_file:&#10;            fs = FileSystemStorage(location='uploaded_images/')&#10;            filename = fs.save(image_file.name, image_file)&#10;            uploaded_image = UploadedImage.objects.create(image=filename)&#10;            # Jump to manage page after upload&#10;            return redirect(reverse('manage_figures'))&#10;        return render(request, 'upload_image.html')&#10;&#10;class InteractiveView(View):&#10;    def get(self, request: HttpRequest, image_id: int):&#10;        try:&#10;            uploaded_image = UploadedImage.objects.get(id=image_id)&#10;            # load existing analysis JSON if present&#10;            analysis_dir = os.path.join(settings.BASE_DIR, 'analysis_results')&#10;            json_path = os.path.join(analysis_dir, f'figure_{image_id}.json')&#10;            existing_analysis = {}&#10;            if os.path.exists(json_path):&#10;                with open(json_path, 'r') as f:&#10;                    existing_analysis = json.load(f)&#10;            # Load the appropriate template based on the category&#10;            if uploaded_image.category == 'barplot':&#10;                template_name = 'interactive_barplot.html'&#10;            elif uploaded_image.category == 'biplot':&#10;                template_name = 'interactive_biplot.html'&#10;            else:&#10;                template_name = 'interactive_scatter.html'&#10;            return render(request, template_name, {&#10;                'uploaded_image': uploaded_image,&#10;                'existing_analysis': existing_analysis&#10;            })&#10;        except UploadedImage.DoesNotExist:&#10;            return redirect('upload_image')&#10;&#10;    def post(self, request: HttpRequest, image_id: int):&#10;        try:&#10;            data = json.loads(request.body)&#10;            # handle save results&#10;            if data.get('saveResults'):&#10;                analysis_dir = os.path.join(settings.BASE_DIR, 'analysis_results')&#10;                os.makedirs(analysis_dir, exist_ok=True)&#10;                json_path = os.path.join(analysis_dir, f'figure_{image_id}.json')&#10;                with open(json_path, 'w') as f:&#10;                    json.dump({'calibration': data.get('calibration', []), 'extractedData': data.get('extractedData', [])}, f)&#10;                return JsonResponse({'status': 'success', 'message': 'Analysis saved'})&#10;            # calibration and extracted handling unchanged&#10;            if 'calibration' in data:&#10;                # Handle calibration data&#10;                calibration_data = data['calibration']&#10;                print(&quot;Calibration data received:&quot;, calibration_data)&#10;                return JsonResponse({'status': 'success', 'message': 'Calibration data processed'})&#10;&#10;            if 'extractedData' in data:&#10;                # Handle extracted data points&#10;                extracted_data = data['extractedData']&#10;                print(&quot;Extracted data received:&quot;, extracted_data)&#10;                return JsonResponse({'status': 'success', 'message': 'Extracted data processed'})&#10;&#10;        except json.JSONDecodeError:&#10;            return JsonResponse({'status': 'error', 'message': 'Invalid JSON data'}, status=400)&#10;&#10;        return JsonResponse({'status': 'error', 'message': 'Invalid request'}, status=400)&#10;&#10;class ManageFiguresView(View):&#10;    def get(self, request: HttpRequest):&#10;        figures = UploadedImage.objects.all()&#10;        return render(request, 'manage_figures.html', {'figures': figures})&#10;&#10;    def post(self, request: HttpRequest):&#10;        data = json.loads(request.body)&#10;        if data.get('delete_id'):&#10;            fid = data['delete_id']&#10;            try:&#10;                figure = UploadedImage.objects.get(id=fid)&#10;                # Delete the figure file&#10;                if figure.image:&#10;                    figure.image.delete(save=False)&#10;                # Remove associated JSON file&#10;                analysis_dir = os.path.join(settings.BASE_DIR, 'analysis_results')&#10;                json_path = os.path.join(analysis_dir, f'figure_{fid}.json')&#10;                if os.path.exists(json_path):&#10;                    os.remove(json_path)&#10;                # Delete the database record&#10;                figure.delete()&#10;                return JsonResponse({'status': 'success', 'message': 'Figure and its analysis deleted successfully'})&#10;            except UploadedImage.DoesNotExist:&#10;                return JsonResponse({'status': 'error', 'message': 'Figure not found'}, status=404)&#10;        elif data.get('figure_id'):&#10;            fid = data['figure_id']&#10;            note = data.get('note', None)&#10;            category = data.get('category', None)&#10;            try:&#10;                figure = UploadedImage.objects.get(id=fid)&#10;                if note is not None:&#10;                    figure.note = note&#10;                if category is not None:&#10;                    figure.category = category&#10;                figure.save()&#10;                return JsonResponse({'status': 'success', 'message': 'Note/Category updated'})&#10;            except UploadedImage.DoesNotExist:&#10;                return JsonResponse({'status': 'error', 'message': 'Figure not found'}, status=404)&#10;        return JsonResponse({'status': 'error', 'message': 'Invalid request'}, status=400)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/templates/interactive_image.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/templates/interactive_image.html" />
              <option name="updatedContent" value="&lt;script&gt;&#10;    let calibration = {&#10;        x: [],&#10;        y: []&#10;    };&#10;    let calibratedValues = {&#10;        x: null,&#10;        y: null&#10;    };&#10;    let isCalibrating = true;&#10;&#10;    function handleImageClick(event) {&#10;        const rect = event.target.getBoundingClientRect();&#10;        const x = event.clientX - rect.left;&#10;        const y = event.clientY - rect.top;&#10;&#10;        if (isCalibrating) {&#10;            if (calibration.x.length &lt; 2) {&#10;                calibration.x.push({ x, y });&#10;                alert(`X-axis calibration point ${calibration.x.length} recorded. Please input the value.`);&#10;                const value = prompt(&quot;Enter the value for this X-axis point:&quot;);&#10;                if (value !== null) {&#10;                    calibration.x[calibration.x.length - 1].value = parseFloat(value);&#10;                }&#10;            } else if (calibration.y.length &lt; 2) {&#10;                calibration.y.push({ x, y });&#10;                alert(`Y-axis calibration point ${calibration.y.length} recorded. Please input the value.`);&#10;                const value = prompt(&quot;Enter the value for this Y-axis point:&quot;);&#10;                if (value !== null) {&#10;                    calibration.y[calibration.y.length - 1].value = parseFloat(value);&#10;                }&#10;            }&#10;&#10;            if (calibration.x.length === 2 &amp;&amp; calibration.y.length === 2) {&#10;                isCalibrating = false;&#10;                alert(&quot;Calibration complete! You can now click on data points.&quot;);&#10;                calculateCalibration();&#10;            }&#10;        } else {&#10;            const realValues = calculateRealValues(x, y);&#10;            renderRedDot(x, y);&#10;            alert(`Extracted values: X = ${realValues.x}, Y = ${realValues.y}`);&#10;        }&#10;    }&#10;&#10;    function calculateCalibration() {&#10;        calibratedValues.x = (calibration.x[1].value - calibration.x[0].value) / (calibration.x[1].x - calibration.x[0].x);&#10;        calibratedValues.y = (calibration.y[1].value - calibration.y[0].value) / (calibration.y[1].y - calibration.y[0].y);&#10;    }&#10;&#10;    function calculateRealValues(x, y) {&#10;        const realX = calibration.x[0].value + (x - calibration.x[0].x) * calibratedValues.x;&#10;        const realY = calibration.y[0].value + (y - calibration.y[0].y) * calibratedValues.y;&#10;        return { x: realX, y: realY };&#10;    }&#10;&#10;    function renderRedDot(x, y) {&#10;        const img = document.querySelector(&quot;img&quot;);&#10;        const dot = document.createElement(&quot;div&quot;);&#10;        dot.style.position = &quot;absolute&quot;;&#10;        dot.style.left = `${x}px`;&#10;        dot.style.top = `${y}px`;&#10;        dot.style.width = &quot;5px&quot;;&#10;        dot.style.height = &quot;5px&quot;;&#10;        dot.style.backgroundColor = &quot;red&quot;;&#10;        dot.style.borderRadius = &quot;50%&quot;;&#10;        dot.style.pointerEvents = &quot;none&quot;;&#10;        img.parentElement.appendChild(dot);&#10;    }&#10;&lt;/script&gt;&#10;&#10;&lt;style&gt;&#10;    body {&#10;        position: relative;&#10;    }&#10;&lt;/style&gt;&#10;&#10;&lt;!-- Updated image tag --&gt;&#10;&lt;img src=&quot;/uploaded_images/{{ uploaded_image.image }}&quot; alt=&quot;Uploaded Image&quot; onclick=&quot;handleImageClick(event)&quot; style=&quot;max-width: 100%; height: auto; position: relative;&quot;&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>